
// !! this file is automatically generated; do not modify.

package org.rekex.exmple.parser.calculator;

import org.rekex.parser.PegParser;
import org.rekex.parser.ParseResult;

import java.util.List;
import org.rekex.exmple.parser.calculator.ExampleParser_Calculator0.Exp0;
import org.rekex.exmple.parser.calculator.ExampleParser_Calculator0.Exp1;
import org.rekex.exmple.parser.calculator.ExampleParser_Calculator0.Exp2;
import org.rekex.exmple.parser.calculator.ExampleParser_Calculator0.Num;
import org.rekex.exmple.parser.calculator.ExampleParser_Calculator0.Parens;
import org.rekex.helper.datatype.SepBy1;
import org.rekex.helper.datatype.seq.Seq2;


// Generated recursive descent PEG parser by Rekex

// rootType: Exp0

// !! this file is automatically generated; do not modify.
@SuppressWarnings({"all", "unchecked"})
public class Generated_ExampleParser_Calculator0 implements PegParser<Exp0>
{
    static final int rootTypeRuleId = 0;

    final Object catalog;
    public Generated_ExampleParser_Calculator0()
    {
        this.catalog = null;
    }

    @Override
    public ParseResult<Exp0> parse(CharSequence chars, int start, int end)
    {
        _State state = new _State();
        state.catalog = this.catalog;
        state.chars = chars;
        state.start = start;
        state.end = end;
        state.inputInfo = new org.rekex.parser.InputInfo(chars, start, end);

        try
        {
            state = match(rootTypeRuleId, state, -1);
        }
        catch (_FatalEx fatalEx)
        {
            var stack = pathToStack(state.path, state.pathLen);
            return new ParseResult.Fatal<>(fatalEx.position, fatalEx.cause, stack);
        }

        if(!state.fail)
        {
            Exp0 obj = state.pickObj();
            if(state.start==state.end)
                return new ParseResult.Full<>(obj);
            else
                return new ParseResult.Partial<>(obj, state.start);
        }
        else
        {
            var stack = pathToStack(state.maxFailPath, state.maxFailPath.length);
            String msg = failMsg(state.maxFailReason, state.maxFailEx, _DatatypeList.list.get(state.maxFailRuleId));
            return new ParseResult.Fail<>(state.maxFailPos, msg, state.maxFailEx, stack);
        }
    }

    final static class _State implements Cloneable
    {
        Object catalog;
        CharSequence chars;
        int start;
        int end;

        org.rekex.parser.InputInfo inputInfo;

        boolean fail;
        // if fail==false, match is success, obj is set (null is allowed)
        Object obj;

        int[] path = new int[64];
        int pathLen = 0;

        int maxFailPos = -1;
        int[] maxFailPath;
        int maxFailReason;
        Exception maxFailEx;
        int maxFailRuleId;

        public _State clone()
        {
            try {
                return (_State)super.clone();
            } catch (CloneNotSupportedException e) {
                throw new AssertionError(e);
            }
        }

        int gStart, gEnd; // tmp data buffer for regex

        void pathPush(int ruleId, int subIndex)
        {
            if(pathLen+3 > path.length)
                path = java.util.Arrays.copyOf(path, path.length+64);
            path[pathLen++] = ruleId;
            path[pathLen++] = this.start;
            path[pathLen++] = subIndex;
        }
        void pathPop()
        {
            pathLen -= 3;
        }

        _State ok(Object obj)
        {
            this.fail = false;
            this.obj = obj;
            return this;
        }
        <T> T pickObj()
        {
            T t = (T)obj;
            obj = null;
            return t;
        }

        _State fail(int position, int reason, Exception ex, int ruleId, int startReset)
        {
            if(position>maxFailPos)
            {
                maxFailPos = position;
                maxFailPath = java.util.Arrays.copyOf(path, pathLen);
                maxFailReason = reason;
                maxFailEx = ex;
                maxFailRuleId = ruleId;
            }
            return fail(startReset);
        }
        _State fail(int startReset)
        {
            this.fail = true;
            this.obj = null;
            this.start = startReset;
            return this;
        }

    }
    static final int failReason_predicate = 0;   // info: Exception
    static final int failReason_neg = 1;         // info: subrule ID
    static final int failReason_regex = 2;
    static final int failReason_regex_group = 3;

    static String failMsg(int reason, Exception ex, org.rekex.annotype.AnnoType type)
    {
        String typeStr = type.toString(false);
        return switch (reason){
            case failReason_predicate
                -> ex.getMessage()!=null ? ex.getMessage() : ex.toString();
            case failReason_neg
                -> typeStr + " failed; input matched subrule";
            case failReason_regex
                -> "Input does not match regex: "+typeStr;
            case failReason_regex_group
                -> "Input does not match regex group: "+typeStr;
            default -> throw new AssertionError("unexpected reason: "+reason);
        };
    }

    static java.util.ArrayList<ParseResult.Node> pathToStack(int[] path, int pathLen)
    {
        java.util.ArrayList<ParseResult.Node> stack = new java.util.ArrayList<>(pathLen/2);
        for(int i=pathLen-1; i>=0;)
        {
            int _subIndex = path[i--];
            int _start = path[i--];
            int _ruleId = path[i--];
            var datatype = _DatatypeList.list.get(_ruleId);
            stack.add(new ParseResult.Node(datatype, _start, _subIndex));
        }
        return stack;
    }

    static class _FatalEx extends Exception
    {
        final int position;
        final Exception cause;
        _FatalEx(int position, Exception cause)
        {
            super(null, null, false, false);
            this.position = position;
            this.cause = cause;
        }
    }

    // = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
    // rules
    // = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

    static _State match(int ruleId, _State state, int subIndex) throws _FatalEx
    {
        state.pathPush(ruleId, subIndex);
        state = switch(ruleId){
            case 0 -> rule_0(state); // Exp0
            case 1 -> rule_1(state); // SepBy1<Exp1,@Ch("+-")String>
            case 2 -> rule_2(state); // Exp1
            case 3 -> rule_3(state); // List<Seq2<@Ch("+-")String,Exp1>>
            case 4 -> rule_4(state); // SepBy1<Exp2,@Ch("*/")String>
            case 5 -> rule_5(state); // Seq2<@Ch("+-")String,Exp1>
            case 6 -> rule_6(state); // Exp2
            case 7 -> rule_7(state); // List<Seq2<@Ch("*/")String,Exp2>>
            case 8 -> rule_8(state); // @Ch("+-")String
            case 9 -> rule_9(state); // Parens
            case 10 -> rule_10(state); // Num
            case 11 -> rule_11(state); // Seq2<@Ch("*/")String,Exp2>
            case 12 -> rule_12(state); // @Ch("(")Void
            case 13 -> rule_13(state); // @Ch(")")Void
            case 14 -> rule_14(state); // @Regex("[0-9]+")String
            case 15 -> rule_15(state); // @Ch("*/")String
            default -> throw new AssertionError("unknown ruleId: "+ruleId);
        };
        state.pathPop();
        return state;
    }

    // concat rule for: Exp0
    static _State rule_0(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(1, state, 0); // arg_0: SepBy1<Exp1,@Ch("+-")String>
        if(state.fail)
            return state.fail(start0);
        SepBy1<Exp1, String> arg_0 = state.pickObj();

        Exp0 value;
        try{
            value = new Exp0(arg_0);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: SepBy1<Exp1,@Ch("+-")String>
    static _State rule_1(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(2, state, 0); // arg_0: Exp1
        if(state.fail)
            return state.fail(start0);
        Exp1 arg_0 = state.pickObj();

        state = match(3, state, 1); // arg_1: List<Seq2<@Ch("+-")String,Exp1>>
        if(state.fail)
            return state.fail(start0);
        List<Seq2<String, Exp1>> arg_1 = state.pickObj();

        SepBy1<Exp1, String> value;
        try{
            value = SepBy1.ctor(arg_0, arg_1);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Exp1
    static _State rule_2(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(4, state, 0); // arg_0: SepBy1<Exp2,@Ch("*/")String>
        if(state.fail)
            return state.fail(start0);
        SepBy1<Exp2, String> arg_0 = state.pickObj();

        Exp1 value;
        try{
            value = new Exp1(arg_0);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // repeat rule for: List<Seq2<@Ch("+-")String,Exp1>>
    static _State rule_3(_State state) throws _FatalEx
    {
        state = match_repeat(state, 3, 5, 0, Integer.MAX_VALUE);
        if(state.fail)
            return state;
        java.util.ArrayList<Seq2<String, Exp1>> list = state.pickObj();
        list.trimToSize();
        return state.ok(list);
    }

    // concat rule for: SepBy1<Exp2,@Ch("*/")String>
    static _State rule_4(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(6, state, 0); // arg_0: Exp2
        if(state.fail)
            return state.fail(start0);
        Exp2 arg_0 = state.pickObj();

        state = match(7, state, 1); // arg_1: List<Seq2<@Ch("*/")String,Exp2>>
        if(state.fail)
            return state.fail(start0);
        List<Seq2<String, Exp2>> arg_1 = state.pickObj();

        SepBy1<Exp2, String> value;
        try{
            value = SepBy1.ctor(arg_0, arg_1);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Seq2<@Ch("+-")String,Exp1>
    static _State rule_5(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(8, state, 0); // arg_0: @Ch("+-")String
        if(state.fail)
            return state.fail(start0);
        String arg_0 = state.pickObj();

        state = match(2, state, 1); // arg_1: Exp1
        if(state.fail)
            return state.fail(start0);
        Exp1 arg_1 = state.pickObj();

        Seq2<String, Exp1> value;
        try{
            value = new Seq2<String, Exp1>(arg_0, arg_1);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // alt rule for: Exp2
    static _State rule_6(_State state) throws _FatalEx
    {
        state = match(9, state, 0); // Parens
        if(!state.fail)
            return state;

        state = match(10, state, 1); // Num
        if(!state.fail)
            return state;

        return state;
    }


    // repeat rule for: List<Seq2<@Ch("*/")String,Exp2>>
    static _State rule_7(_State state) throws _FatalEx
    {
        state = match_repeat(state, 7, 11, 0, Integer.MAX_VALUE);
        if(state.fail)
            return state;
        java.util.ArrayList<Seq2<String, Exp2>> list = state.pickObj();
        list.trimToSize();
        return state.ok(list);
    }

    // regex rule for: @Ch("+-")String
    static _State rule_8(_State state)
    {
        return match_regex_str(state, 8, pattern_8, 0);
    }
    static final java.util.regex.Pattern pattern_8 = java.util.regex.Pattern.compile("[\\+\\-]", 0);

    // concat rule for: Parens
    static _State rule_9(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(12, state, 0); // arg_0: @Ch("(")Void
        if(state.fail)
            return state.fail(start0);
        Void arg_0 = state.pickObj();

        state = match(0, state, 1); // arg_1: Exp0
        if(state.fail)
            return state.fail(start0);
        Exp0 arg_1 = state.pickObj();

        state = match(13, state, 2); // arg_2: @Ch(")")Void
        if(state.fail)
            return state.fail(start0);
        Void arg_2 = state.pickObj();

        Parens value;
        try{
            value = new Parens(arg_0, arg_1, arg_2);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Num
    static _State rule_10(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(14, state, 0); // arg_0: @Regex("[0-9]+")String
        if(state.fail)
            return state.fail(start0);
        String arg_0 = state.pickObj();

        Num value;
        try{
            value = new Num(arg_0);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Seq2<@Ch("*/")String,Exp2>
    static _State rule_11(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(15, state, 0); // arg_0: @Ch("*/")String
        if(state.fail)
            return state.fail(start0);
        String arg_0 = state.pickObj();

        state = match(6, state, 1); // arg_1: Exp2
        if(state.fail)
            return state.fail(start0);
        Exp2 arg_1 = state.pickObj();

        Seq2<String, Exp2> value;
        try{
            value = new Seq2<String, Exp2>(arg_0, arg_1);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // regex rule for: @Ch("(")Void
    static _State rule_12(_State state)
    {
        return match_regex(state, 12, pattern_12, 0);
    }
    static final java.util.regex.Pattern pattern_12 = java.util.regex.Pattern.compile("\\(", 0);

    // regex rule for: @Ch(")")Void
    static _State rule_13(_State state)
    {
        return match_regex(state, 13, pattern_13, 0);
    }
    static final java.util.regex.Pattern pattern_13 = java.util.regex.Pattern.compile("\\)", 0);

    // regex rule for: @Regex("[0-9]+")String
    static _State rule_14(_State state)
    {
        return match_regex_str(state, 14, pattern_14, 0);
    }
    static final java.util.regex.Pattern pattern_14 = java.util.regex.Pattern.compile("[0-9]+", 0);

    // regex rule for: @Ch("*/")String
    static _State rule_15(_State state)
    {
        return match_regex_str(state, 15, pattern_15, 0);
    }
    static final java.util.regex.Pattern pattern_15 = java.util.regex.Pattern.compile("[\\*/]", 0);



    // = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
    //
    // = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

    static _State match_repeat(_State state, int ruleId, int subRuleId, int min, int max) throws _FatalEx
    {
        final int start0 = state.start;
        java.util.ArrayList<Object> list = new java.util.ArrayList<>(Math.max(min, Math.min(10, max)));
        for(int i=0; i<max; i++)
        {
            final int start1 = state.start;
            state = match(subRuleId, state, i);
            if(i<min && state.fail)
                return state.fail(start0);
            if(i>=min && state.fail) // enough elements
                break;
            if(i>=min && start1==state.start) // no progress, enough elements
                break;
            list.add(state.pickObj());
        }
        return state.ok(list);
    }

    static _State match_regex(_State state, int ruleId, java.util.regex.Pattern pattern, int group)
    {
        var matcher = pattern.matcher(state.chars);
        matcher.region(state.start, state.end);
        boolean matched = matcher.lookingAt();
        if(!matched)
            return state.fail(state.start, failReason_regex, null, ruleId, state.start);

        state.gStart = matcher.start(group);
        state.gEnd = matcher.end(group);
        if(state.gStart==-1)
            return state.fail(state.start, failReason_regex_group, null, ruleId, state.start);

        state.start = matcher.end(0); // consume group 0
        return state.ok(null);
    }
    static _State match_regex_str(_State state, int ruleId, java.util.regex.Pattern pattern, int group)
    {
        state = match_regex(state, ruleId, pattern, group);
        if(state.fail)
            return state;
        String str = state.chars.subSequence(state.gStart, state.gEnd).toString();
        return state.ok(str);
    }
    static class _DatatypeList
    {
        // [0] Exp0
        static org.rekex.exmple.parser.calculator.ExampleParser_Calculator0.Exp0 t_0;
        // [1] SepBy1<Exp1,@Ch("+-")String>
        static org.rekex.helper.datatype.SepBy1<org.rekex.exmple.parser.calculator.ExampleParser_Calculator0.Exp1,java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="+-")String> t_1;
        // [2] Exp1
        static org.rekex.exmple.parser.calculator.ExampleParser_Calculator0.Exp1 t_2;
        // [3] List<Seq2<@Ch("+-")String,Exp1>>
        static java.util.List<org.rekex.helper.datatype.seq.Seq2<java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="+-")String,org.rekex.exmple.parser.calculator.ExampleParser_Calculator0.Exp1>> t_3;
        // [4] SepBy1<Exp2,@Ch("*/")String>
        static org.rekex.helper.datatype.SepBy1<org.rekex.exmple.parser.calculator.ExampleParser_Calculator0.Exp2,java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="*/")String> t_4;
        // [5] Seq2<@Ch("+-")String,Exp1>
        static org.rekex.helper.datatype.seq.Seq2<java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="+-")String,org.rekex.exmple.parser.calculator.ExampleParser_Calculator0.Exp1> t_5;
        // [6] Exp2
        static org.rekex.exmple.parser.calculator.ExampleParser_Calculator0.Exp2 t_6;
        // [7] List<Seq2<@Ch("*/")String,Exp2>>
        static java.util.List<org.rekex.helper.datatype.seq.Seq2<java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="*/")String,org.rekex.exmple.parser.calculator.ExampleParser_Calculator0.Exp2>> t_7;
        // [8] @Ch("+-")String
        static java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="+-")String t_8;
        // [9] Parens
        static org.rekex.exmple.parser.calculator.ExampleParser_Calculator0.Parens t_9;
        // [10] Num
        static org.rekex.exmple.parser.calculator.ExampleParser_Calculator0.Num t_10;
        // [11] Seq2<@Ch("*/")String,Exp2>
        static org.rekex.helper.datatype.seq.Seq2<java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="*/")String,org.rekex.exmple.parser.calculator.ExampleParser_Calculator0.Exp2> t_11;
        // [12] @Ch("(")Void
        static java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="(")Void t_12;
        // [13] @Ch(")")Void
        static java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value=")")Void t_13;
        // [14] @Regex("[0-9]+")String
        static java.lang.@org.rekex.spec.Regex(flags=0, group=0, value="[0-9]+")String t_14;
        // [15] @Ch("*/")String
        static java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="*/")String t_15;

        static final java.util.ArrayList<org.rekex.annotype.AnnoType> list = new java.util.ArrayList<>();
        static
        {
            for(int id=0; id<16; id++)
            {
                java.lang.reflect.Field field;
                try{ field = _DatatypeList.class.getDeclaredField("t_"+id); }
                catch(Exception ex){ ex.printStackTrace(); throw new Error(ex); }
                var type = org.rekex.annotype.TypeMath.convertFromJlr(field.getAnnotatedType());
                list.add(type);
            }
        }
    }

}
